%---------------------------------------------------------------------------
%
% :File:       report.tex
% :Purpose:    Report for 17-652
%
%---------------------------------------------------------------------------

\documentclass[11pt]{article}
\usepackage{fullpage}
% \usepackage{amsmath,amsfonts,enumerate}
% \usepackage{zed-csp}
\usepackage{graphicx}
% \usepackage{xcolor}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}


% Define admin constants
\def\name{Daniel Pagan}
\def\course{Models of Software Systems}
\def\due{1 December 2021}
\def\title{Independent Project: Hazard Pointers}

\usepackage{latexsym}
\usepackage{ifthen}
% \usepackage{color}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SWITCHES                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newboolean{shading}
\setboolean{shading}{false}
\makeatletter
%% this is needed only when inserted into the file, not when
%% used as a package file.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                           %
% DEFINITIONS OF SYMBOL-PRODUCING COMMANDS                                  %
%                                                                           %
%    TLA+      LaTeX                                                        %
%    symbol    command                                                      %
%    ------    -------                                                      %
%    =>        \implies                                                     %
%    <:        \ltcolon                                                     %
%    :>        \colongt                                                     %
%    ==        \defeq                                                       %
%    ..        \dotdot                                                      %
%    ::        \coloncolon                                                  %
%    =|        \eqdash                                                      %
%    ++        \pp                                                          %
%    --        \mm                                                          %
%    **        \stst                                                        %
%    //        \slsl                                                        %
%    ^         \ct                                                          %
%    \A        \A                                                           %
%    \E        \E                                                           %
%    \AA       \AA                                                          %
%    \EE       \EE                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newlength{\symlength}
\newcommand{\implies}{\Rightarrow}
\newcommand{\ltcolon}{\mathrel{<\!\!\mbox{:}}}
\newcommand{\colongt}{\mathrel{\!\mbox{:}\!\!>}}
\newcommand{\defeq}{\;\mathrel{\smash   %% keep this symbol from being too tall
        {{\stackrel{\scriptscriptstyle\Delta}{=}}}}\;}
\newcommand{\dotdot}{\mathrel{\ldotp\ldotp}}
\newcommand{\coloncolon}{\mathrel{::\;}}
\newcommand{\eqdash}{\mathrel = \joinrel \hspace{-.28em}|}
\newcommand{\pp}{\mathbin{++}}
\newcommand{\mm}{\mathbin{--}}
\newcommand{\stst}{*\!*}
\newcommand{\slsl}{/\!/}
\newcommand{\ct}{\hat{\hspace{.4em}}}
\newcommand{\A}{\forall}
\newcommand{\E}{\exists}
\renewcommand{\AA}{\makebox{$\raisebox{.05em}{\makebox[0pt][l]{%
                    $\forall\hspace{-.517em}\forall\hspace{-.517em}\forall$}}%
            \forall\hspace{-.517em}\forall \hspace{-.517em}\forall\,$}}
\newcommand{\EE}{\makebox{$\raisebox{.05em}{\makebox[0pt][l]{%
                    $\exists\hspace{-.517em}\exists\hspace{-.517em}\exists$}}%
            \exists\hspace{-.517em}\exists\hspace{-.517em}\exists\,$}}
\newcommand{\whileop}{\.{\stackrel
{\mbox{\raisebox{-.3em}[0pt][0pt]{$\scriptscriptstyle+\;\,$}}}%
{-\hspace{-.16em}\triangleright}}}

% Commands are defined to produce the upper-case keywords.
% Note that some have space after them.
\newcommand{\ASSUME}{\textsc{assume }}
\newcommand{\ASSUMPTION}{\textsc{assumption }}
\newcommand{\AXIOM}{\textsc{axiom }}
\newcommand{\BOOLEAN}{\textsc{boolean }}
\newcommand{\CASE}{\textsc{case }}
\newcommand{\CONSTANT}{\textsc{constant }}
\newcommand{\CONSTANTS}{\textsc{constants }}
\newcommand{\ELSE}{\settowidth{\symlength}{\THEN}%
    \makebox[\symlength][l]{\textsc{ else}}}
\newcommand{\EXCEPT}{\textsc{ except }}
\newcommand{\EXTENDS}{\textsc{extends }}
\newcommand{\FALSE}{\textsc{false}}
\newcommand{\IF}{\textsc{if }}
\newcommand{\IN}{\settowidth{\symlength}{\LET}%
    \makebox[\symlength][l]{\textsc{in}}}
\newcommand{\INSTANCE}{\textsc{instance }}
\newcommand{\LET}{\textsc{let }}
\newcommand{\LOCAL}{\textsc{local }}
\newcommand{\MODULE}{\textsc{module }}
\newcommand{\OTHER}{\textsc{other }}
\newcommand{\STRING}{\textsc{string}}
\newcommand{\THEN}{\textsc{ then }}
\newcommand{\THEOREM}{\textsc{theorem }}
\newcommand{\LEMMA}{\textsc{lemma }}
\newcommand{\PROPOSITION}{\textsc{proposition }}
\newcommand{\COROLLARY}{\textsc{corollary }}
\newcommand{\TRUE}{\textsc{true}}
\newcommand{\VARIABLE}{\textsc{variable }}
\newcommand{\VARIABLES}{\textsc{variables }}
\newcommand{\WITH}{\textsc{ with }}
\newcommand{\WF}{\textrm{WF}}
\newcommand{\SF}{\textrm{SF}}
\newcommand{\CHOOSE}{\textsc{choose }}
\newcommand{\ENABLED}{\textsc{enabled }}
\newcommand{\UNCHANGED}{\textsc{unchanged }}
\newcommand{\SUBSET}{\textsc{subset }}
\newcommand{\UNION}{\textsc{union }}
\newcommand{\DOMAIN}{\textsc{domain }}
% Added for tla2tex
\newcommand{\BY}{\textsc{by }}
\newcommand{\OBVIOUS}{\textsc{obvious }}
\newcommand{\HAVE}{\textsc{have }}
\newcommand{\QED}{\textsc{qed }}
\newcommand{\TAKE}{\textsc{take }}
\newcommand{\DEF}{\textsc{ def }}
\newcommand{\HIDE}{\textsc{hide }}
\newcommand{\RECURSIVE}{\textsc{recursive }}
\newcommand{\USE}{\textsc{use }}
\newcommand{\DEFINE}{\textsc{define }}
\newcommand{\PROOF}{\textsc{proof }}
\newcommand{\WITNESS}{\textsc{witness }}
\newcommand{\PICK}{\textsc{pick }}
\newcommand{\DEFS}{\textsc{defs }}
\newcommand{\PROVE}{\settowidth{\symlength}{\ASSUME}%
    \makebox[\symlength][l]{\textsc{prove}}\@s{-4.1}}%
%% The \@s{-4.1) is a kludge added on 24 Oct 2009 [happy birthday, Ellen]
%% so the correct alignment occurs if the user types
%%   ASSUME X
%%   PROVE  Y
%% because it cancels the extra 4.1 pts added because of the 
%% extra space after the PROVE.  This seems to works OK.
%% However, the 4.1 equals Parameters.LaTeXLeftSpace(1) and
%% should be changed if that method ever changes.
\newcommand{\SUFFICES}{\textsc{suffices }}
\newcommand{\NEW}{\textsc{new }}
\newcommand{\LAMBDA}{\textsc{lambda }}
\newcommand{\STATE}{\textsc{state }}
\newcommand{\ACTION}{\textsc{action }}
\newcommand{\TEMPORAL}{\textsc{temporal }}
\newcommand{\ONLY}{\textsc{only }}              %% added by LL on 2 Oct 2009
\newcommand{\OMITTED}{\textsc{omitted }}        %% added by LL on 31 Oct 2009
\newcommand{\@pfstepnum}[2]{\ensuremath{\langle#1\rangle}\textrm{#2}}
\newcommand{\bang}{\@s{1}\mbox{\small !}\@s{1}}
%% We should format || differently in PlusCal code than in TLA+ formulas.
\newcommand{\p@barbar}{\ifpcalsymbols
        \,\,\rule[-.25em]{.075em}{1em}\hspace*{.2em}\rule[-.25em]{.075em}{1em}\,\,%
    \else \,||\,\fi}
%% PlusCal keywords
\newcommand{\p@fair}{\textbf{fair }}
\newcommand{\p@semicolon}{\textbf{\,; }}
\newcommand{\p@algorithm}{\textbf{algorithm }}
\newcommand{\p@mmfair}{\textbf{-{}-fair }}
\newcommand{\p@mmalgorithm}{\textbf{-{}-algorithm }}
\newcommand{\p@assert}{\textbf{assert }}
\newcommand{\p@await}{\textbf{await }}
\newcommand{\p@begin}{\textbf{begin }}
\newcommand{\p@end}{\textbf{end }}
\newcommand{\p@call}{\textbf{call }}
\newcommand{\p@define}{\textbf{define }}
\newcommand{\p@do}{\textbf{ do }}
\newcommand{\p@either}{\textbf{either }}
\newcommand{\p@or}{\textbf{or }}
\newcommand{\p@goto}{\textbf{goto }}
\newcommand{\p@if}{\textbf{if }}
\newcommand{\p@then}{\,\,\textbf{then }}
\newcommand{\p@else}{\ifcsyntax \textbf{else } \else \,\,\textbf{else }\fi}
\newcommand{\p@elsif}{\,\,\textbf{elsif }}
\newcommand{\p@macro}{\textbf{macro }}
\newcommand{\p@print}{\textbf{print }}
\newcommand{\p@procedure}{\textbf{procedure }}
\newcommand{\p@process}{\textbf{process }}
\newcommand{\p@return}{\textbf{return}}
\newcommand{\p@skip}{\textbf{skip}}
\newcommand{\p@variable}{\textbf{variable }}
\newcommand{\p@variables}{\textbf{variables }}
\newcommand{\p@while}{\textbf{while }}
\newcommand{\p@when}{\textbf{when }}
\newcommand{\p@with}{\textbf{with }}
\newcommand{\p@lparen}{\textbf{(\,\,}}
\newcommand{\p@rparen}{\textbf{\,\,) }}
\newcommand{\p@lbrace}{\textbf{\{\,\,}}
\newcommand{\p@rbrace}{\textbf{\,\,\} }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% REDEFINE STANDARD COMMANDS TO MAKE THEM FORMAT BETTER %
%                                                       %
% We redefine \in and \notin                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\_}{\rule{.4em}{.06em}\hspace{.05em}}
\newlength{\equalswidth}
\let\oldin=\in
\let\oldnotin=\notin
\renewcommand{\in}{%
{\settowidth{\equalswidth}{$\.{=}$}\makebox[\equalswidth][c]{$\oldin$}}}
\renewcommand{\notin}{%
{\settowidth{\equalswidth}{$\.{=}$}\makebox[\equalswidth]{$\oldnotin$}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                  %
% HORIZONTAL BARS:                                 %
%                                                  %
%   \moduleLeftDash    |~~~~~~~~~~                 %
%   \moduleRightDash    ~~~~~~~~~~|                %
%   \midbar            |----------|                %
%   \bottombar         |__________|                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newlength{\charwidth}\settowidth{\charwidth}{{\small\tt M}}
\newlength{\boxrulewd}\setlength{\boxrulewd}{.4pt}
\newlength{\boxlineht}\setlength{\boxlineht}{.5\baselineskip}
\newcommand{\boxsep}{\charwidth}
\newlength{\boxruleht}\setlength{\boxruleht}{.5ex}
\newlength{\boxruledp}\setlength{\boxruledp}{-\boxruleht}
\addtolength{\boxruledp}{\boxrulewd}
\newcommand{\boxrule}{\leaders\hrule height \boxruleht depth \boxruledp
    \hfill\mbox{}}
\newcommand{\@computerule}{%
    \setlength{\boxruleht}{.5ex}%
    \setlength{\boxruledp}{-\boxruleht}%
    \addtolength{\boxruledp}{\boxrulewd}}

\newcommand{\bottombar}{\hspace{-\boxsep}%
    \raisebox{-\boxrulewd}[0pt][0pt]{\rule[.5ex]{\boxrulewd}{\boxlineht}}%
    \boxrule
    \raisebox{-\boxrulewd}[0pt][0pt]{%
        \rule[.5ex]{\boxrulewd}{\boxlineht}}\hspace{-\boxsep}\vspace{0pt}}

\newcommand{\moduleLeftDash}%
{\hspace*{-\boxsep}%
    \raisebox{-\boxlineht}[0pt][0pt]{\rule[.5ex]{\boxrulewd
        }{\boxlineht}}%
    \boxrule\hspace*{.4em }}

\newcommand{\moduleRightDash}%
{\hspace*{.4em}\boxrule
    \raisebox{-\boxlineht}[0pt][0pt]{\rule[.5ex]{\boxrulewd
        }{\boxlineht}}\hspace{-\boxsep}}%\vspace{.2em}

\newcommand{\midbar}{\hspace{-\boxsep}\raisebox{-.5\boxlineht}[0pt][0pt]{%
        \rule[.5ex]{\boxrulewd}{\boxlineht}}\boxrule\raisebox{-.5\boxlineht%
    }[0pt][0pt]{\rule[.5ex]{\boxrulewd}{\boxlineht}}\hspace{-\boxsep}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FORMATING COMMANDS                                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLUSCAL SHADING                                                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The TeX pcalshading switch is set on to cause PlusCal shading to be
% performed.  This changes the behavior of the following commands and
% environments to cause full-width shading to be performed on all lines.
% 
%   \tstrut \@x cpar mcom \@pvspace
% 
% The TeX pcalsymbols switch is turned on when typesetting a PlusCal algorithm,
% whether or not shading is being performed.  It causes symbols (other than
% parentheses and braces and PlusCal-only keywords) that should be typeset
% differently depending on whether they are in an algorithm to be typeset
% appropriately.  Currently, the only such symbol is "||".
%
% The TeX csyntax switch is turned on when typesetting a PlusCal algorithm in
% c-syntax.  This allows symbols to be format differently in the two syntaxes.
% The "else" keyword is the only one that is.

\newif\ifpcalshading \pcalshadingfalse
\newif\ifpcalsymbols \pcalsymbolsfalse
\newif\ifcsyntax     \csyntaxtrue

% The \@pvspace command makes a vertical space.  It uses \vspace
% except with \ifpcalshading, in which case it sets \pvcalvspace
% and the space is added by a following \@x command.
%
\newlength{\pcalvspace}\setlength{\pcalvspace}{0pt}%
\newcommand{\@pvspace}[1]{%
    \ifpcalshading
        \par\global\setlength{\pcalvspace}{#1}%
    \else
        \par\vspace{#1}%
    \fi
}

% The lcom environment was changed to set \lcomindent equal to
% the indentation it produces.  This length is used by the
% cpar environment to make shading extend for the full width
% of the line.  This assumes that lcom environments are not
% nested.  I hope TLATeX does not nest them.
%
\newlength{\lcomindent}%
\setlength{\lcomindent}{0pt}%

%\tstrut: A strut to produce inter-paragraph space in a comment.
%\rstrut: A strut to extend the bottom of a one-line comment so
%         there's no break in the shading between comments on 
%         successive lines.
\newcommand\tstrut%
{\raisebox{\vshadelen}{\raisebox{-.25em}{\rule{0pt}{1.15em}}}%
    \global\setlength{\vshadelen}{0pt}}
\newcommand\rstrut{\raisebox{-.25em}{\rule{0pt}{1.15em}}%
    \global\setlength{\vshadelen}{0pt}}


% \.{op} formats operator op in math mode with empty boxes on either side.
% Used because TeX otherwise vary the amount of space it leaves around op.
\renewcommand{\.}[1]{\ensuremath{\mbox{}#1\mbox{}}}

% \@s{n} produces an n-point space
\newcommand{\@s}[1]{\hspace{#1pt}}

% \@x{txt} starts a specification line in the beginning with txt
% in the final LaTeX source.
\newlength{\@xlen}
\newcommand\xtstrut%
{\setlength{\@xlen}{1.05em}%
    \addtolength{\@xlen}{\pcalvspace}%
    \raisebox{\vshadelen}{\raisebox{-.25em}{\rule{0pt}{\@xlen}}}%
    \global\setlength{\vshadelen}{0pt}%
    \global\setlength{\pcalvspace}{0pt}}

\newcommand{\@x}[1]{\par
    \ifpcalshading
        \makebox[0pt][l]{\shadebox{\xtstrut\hspace*{\textwidth}}}%
    \fi
    \mbox{$\mbox{}#1\mbox{}$}}

% \@xx{txt} continues a specification line with the text txt.
\newcommand{\@xx}[1]{\mbox{$\mbox{}#1\mbox{}$}}

% \@y{cmt} produces a one-line comment.
\newcommand{\@y}[1]{\mbox{\footnotesize\hspace{.65em}%
        \ifthenelse{\boolean{shading}}{%
            \shadebox{#1\hspace{-\the\lastskip}\rstrut}}%
        {#1\hspace{-\the\lastskip}\rstrut}}}

% \@z{cmt} produces a zero-width one-line comment.
\newcommand{\@z}[1]{\makebox[0pt][l]{\footnotesize
        \ifthenelse{\boolean{shading}}{%
            \shadebox{#1\hspace{-\the\lastskip}\rstrut}}%
        {#1\hspace{-\the\lastskip}\rstrut}}}


% \@w{str} produces the TLA+ string "str".
\newcommand{\@w}[1]{\textsf{``{#1}''}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SHADING                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\graymargin{1}
% The number of points of margin in the shaded box.

% \definecolor{boxshade}{gray}{.85}
% Defines the darkness of the shading: 1 = white, 0 = black
% Added by TLATeX only if needed.

% \shadebox{txt} puts txt in a shaded box.
\newlength{\templena}
\newlength{\templenb}
\newsavebox{\tempboxa}
\newcommand{\shadebox}[1]{{\setlength{\fboxsep}{\graymargin pt}%
            \savebox{\tempboxa}{#1}%
            \settoheight{\templena}{\usebox{\tempboxa}}%
            \settodepth{\templenb}{\usebox{\tempboxa}}%
            \hspace*{-\fboxsep}\raisebox{0pt}[\templena][\templenb]%
            {\colorbox{boxshade}{\usebox{\tempboxa}}}\hspace*{-\fboxsep}}}

% \vshade{n} makes an n-point inter-paragraph space, with
%  shading if the `shading' flag is true.
\newlength{\vshadelen}
\setlength{\vshadelen}{0pt}
\newcommand{\vshade}[1]{\ifthenelse{\boolean{shading}}%
    {\global\setlength{\vshadelen}{#1pt}}%
    {\vspace{#1pt}}}

\newlength{\boxwidth}
\newlength{\multicommentdepth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE cpar ENVIRONMENT                                                      %
% ^^^^^^^^^^^^^^^^^^^^                                                      %
% The LaTeX input                                                           %
%                                                                           %
%   \begin{cpar}{pop}{nest}{isLabel}{d}{e}{arg6}                            %
%     XXXXXXXXXXXXXXX                                                       %
%     XXXXXXXXXXXXXXX                                                       %
%     XXXXXXXXXXXXXXX                                                       %
%   \end{cpar}                                                              %
%                                                                           %
% produces one of two possible results.  If isLabel is the letter "T",      %
% it produces the following, where [label] is the result of typesetting     %
% arg6 in an LR box, and d is is a number representing a distance in        %
% points.                                                                   %
%                                                                           %
%   prevailing |<-- d -->[label]<- e ->XXXXXXXXXXXXXXX                      %
%         left |                       XXXXXXXXXXXXXXX                      %
%       margin |                       XXXXXXXXXXXXXXX                      %
%                                                                           %
% If isLabel is the letter "F", then it produces                            %
%                                                                           %
%   prevailing |<-- d -->XXXXXXXXXXXXXXXXXXXXXXX                            %
%         left |         <- e ->XXXXXXXXXXXXXXXX                            %
%       margin |                XXXXXXXXXXXXXXXX                            %
%                                                                           %
% where d and e are numbers representing distances in points.               %
%                                                                           %
% The prevailing left margin is the one in effect before the most recent    %
% pop (argument 1) cpar environments with "T" as the nest argument, where   %
% pop is a number \geq 0.                                                   %
%                                                                           %
% If the nest argument is the letter "T", then the prevailing left          %
% margin is moved to the left of the second (and following) lines of        %
% X's.  Otherwise, the prevailing left margin is left unchanged.            %
%                                                                           %
% An \unnest{n} command moves the prevailing left margin to where it was    %
% before the most recent n cpar environments with "T" as the nesting        %
% argument.                                                                 %
%                                                                           %
% The environment leaves no vertical space above or below it, or between    %
% its paragraphs.  (TLATeX inserts the proper amount of vertical space.)    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcounter{pardepth}
\setcounter{pardepth}{0}

% \setgmargin{txt} defines \gmarginN to be txt, where N is \roman{pardepth}.
% \thegmargin equals \gmarginN, where N is \roman{pardepth}.
\newcommand{\setgmargin}[1]{%
    \expandafter\xdef\csname gmargin\roman{pardepth}\endcsname{#1}}
\newcommand{\thegmargin}{\csname gmargin\roman{pardepth}\endcsname}
\newcommand{\gmargin}{0pt}

\newsavebox{\tempsbox}

\newlength{\@cparht}
\newlength{\@cpardp}
\newenvironment{cpar}[6]{%
    \addtocounter{pardepth}{-#1}%
    \ifthenelse{\boolean{shading}}{\par\begin{lrbox}{\tempsbox}%
            \begin{minipage}[t]{\linewidth}}{}%
                \begin{list}{}{%
                        \edef\temp{\thegmargin}
                        \ifthenelse{\equal{#3}{T}}%
                        {\settowidth{\leftmargin}{\hspace{\temp}\footnotesize #6\hspace{#5pt}}%
                            \addtolength{\leftmargin}{#4pt}}%
                        {\setlength{\leftmargin}{#4pt}%
                            \addtolength{\leftmargin}{#5pt}%
                            \addtolength{\leftmargin}{\temp}%
                            \setlength{\itemindent}{-#5pt}}%
                        \ifthenelse{\equal{#2}{T}}{\addtocounter{pardepth}{1}%
                            \setgmargin{\the\leftmargin}}{}%
                        \setlength{\labelwidth}{0pt}%
                        \setlength{\labelsep}{0pt}%
                        \setlength{\itemindent}{-\leftmargin}%
                        \setlength{\topsep}{0pt}%
                        \setlength{\parsep}{0pt}%
                        \setlength{\partopsep}{0pt}%
                        \setlength{\parskip}{0pt}%
                        \setlength{\itemsep}{0pt}
                        \setlength{\itemindent}{#4pt}%
                        \addtolength{\itemindent}{-\leftmargin}}%
                    \ifthenelse{\equal{#3}{T}}%
                    {\item[\tstrut\footnotesize \hspace{\temp}{#6}\hspace{#5pt}]
                        }%
                        {\item[\tstrut\hspace{\temp}]%
                        }%
                        \footnotesize}
                        {\hspace{-\the\lastskip}\tstrut
                \end{list}%
                \ifthenelse{\boolean{shading}}%
                {\end{minipage}%
        \end{lrbox}%
        \ifpcalshading
            \setlength{\@cparht}{\ht\tempsbox}%
            \setlength{\@cpardp}{\dp\tempsbox}%
            \addtolength{\@cparht}{.15em}%
            \addtolength{\@cpardp}{.2em}%
            \addtolength{\@cparht}{\@cpardp}%
            % I don't know what's going on here.  I want to add a
            % \pcalvspace high shaded line, but I don't know how to
            % do it.  A little trial and error shows that the following
            % does a reasonable job approximating that, eliminating
            % the line if \pcalvspace is small.
            \addtolength{\@cparht}{\pcalvspace}%
            \ifdim \pcalvspace > .8em
                \addtolength{\pcalvspace}{-.2em}%
                \hspace*{-\lcomindent}%
                \shadebox{\rule{0pt}{\pcalvspace}\hspace*{\textwidth}}\par
                \global\setlength{\pcalvspace}{0pt}%
            \fi
            \hspace*{-\lcomindent}%
            \makebox[0pt][l]{\raisebox{-\@cpardp}[0pt][0pt]{%
                    \shadebox{\rule{0pt}{\@cparht}\hspace*{\textwidth}}}}%
            \hspace*{\lcomindent}\usebox{\tempsbox}%
            \par
        \else
            \shadebox{\usebox{\tempsbox}}\par
        \fi}%
    {}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE ppar ENVIRONMENT                                                       %
% ^^^^^^^^^^^^^^^^^^^^                                                       %
% The environment                                                            %
%                                                                            %
%   \begin{ppar} ... \end{ppar}                                              %
%                                                                            %
% is equivalent to                                                           %
%                                                                            %
%   \begin{cpar}{0}{F}{F}{0}{0}{} ... \end{cpar}                             %
%                                                                            %
% The environment is put around each line of the output for a PlusCal        %
% algorithm.                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newenvironment{ppar}{%
%  \ifthenelse{\boolean{shading}}{\par\begin{lrbox}{\tempsbox}%
%                                 \begin{minipage}[t]{\linewidth}}{}%
%  \begin{list}{}{%
%     \edef\temp{\thegmargin}
%        \setlength{\leftmargin}{0pt}%
%        \addtolength{\leftmargin}{\temp}%
%        \setlength{\itemindent}{0pt}%
%      \setlength{\labelwidth}{0pt}%
%      \setlength{\labelsep}{0pt}%
%      \setlength{\itemindent}{-\leftmargin}%
%      \setlength{\topsep}{0pt}%
%      \setlength{\parsep}{0pt}%
%      \setlength{\partopsep}{0pt}%
%      \setlength{\parskip}{0pt}%
%      \setlength{\itemsep}{0pt}
%      \setlength{\itemindent}{0pt}%
%      \addtolength{\itemindent}{-\leftmargin}}%
%      \item[\tstrut\hspace{\temp}]}%
% {\hspace{-\the\lastskip}\tstrut
% \end{list}%
%  \ifthenelse{\boolean{shading}}{\end{minipage}  
%                                 \end{lrbox}%
%                                 \shadebox{\usebox{\tempsbox}}\par}{}%
%  }

%%% TESTING
\newcommand{\xtest}[1]{\par
    \makebox[0pt][l]{\shadebox{\xtstrut\hspace*{\textwidth}}}%
    \mbox{$\mbox{}#1\mbox{}$}}

% \newcommand{\xxtest}[1]{\par
% \makebox[0pt][l]{\shadebox{\xtstrut{#1}\hspace*{\textwidth}}}%
% \mbox{$\mbox{}#1\mbox{}$}} 

%\newlength{\pcalvspace}
%\setlength{\pcalvspace}{0pt}
% \newlength{\xxtestlen}
% \setlength{\xxtestlen}{0pt}
% \newcommand\xtstrut%
%   {\setlength{\xxtestlen}{1.15em}%
%    \addtolength{\xxtestlen}{\pcalvspace}%
%     \raisebox{\vshadelen}{\raisebox{-.25em}{\rule{0pt}{\xxtestlen}}}%
%    \global\setlength{\vshadelen}{0pt}%
%    \global\setlength{\pcalvspace}{0pt}}

%%%% TESTING

%% The xcpar environment
%%  Note: overloaded use of \pcalvspace for testing.
%%
%   \newlength{\xcparht}%
%   \newlength{\xcpardp}%

%   \newenvironment{xcpar}[6]{%
%  \addtocounter{pardepth}{-#1}%
%  \ifthenelse{\boolean{shading}}{\par\begin{lrbox}{\tempsbox}%
%                                 \begin{minipage}[t]{\linewidth}}{}%
%  \begin{list}{}{%
%     \edef\temp{\thegmargin}%
%     \ifthenelse{\equal{#3}{T}}%
%       {\settowidth{\leftmargin}{\hspace{\temp}\footnotesize #6\hspace{#5pt}}%
%        \addtolength{\leftmargin}{#4pt}}%
%       {\setlength{\leftmargin}{#4pt}%
%        \addtolength{\leftmargin}{#5pt}%
%        \addtolength{\leftmargin}{\temp}%
%        \setlength{\itemindent}{-#5pt}}%
%      \ifthenelse{\equal{#2}{T}}{\addtocounter{pardepth}{1}%
%                                 \setgmargin{\the\leftmargin}}{}%
%      \setlength{\labelwidth}{0pt}%
%      \setlength{\labelsep}{0pt}%
%      \setlength{\itemindent}{-\leftmargin}%
%      \setlength{\topsep}{0pt}%
%      \setlength{\parsep}{0pt}%
%      \setlength{\partopsep}{0pt}%
%      \setlength{\parskip}{0pt}%
%      \setlength{\itemsep}{0pt}%
%      \setlength{\itemindent}{#4pt}%
%      \addtolength{\itemindent}{-\leftmargin}}%
%   \ifthenelse{\equal{#3}{T}}%
%      {\item[\xtstrut\footnotesize \hspace{\temp}{#6}\hspace{#5pt}]%
%        }%
%      {\item[\xtstrut\hspace{\temp}]%
%         }%
%   \footnotesize}
% {\hspace{-\the\lastskip}\tstrut
% \end{list}%
%  \ifthenelse{\boolean{shading}}{\end{minipage}  
%                                 \end{lrbox}%
%                                 \setlength{\xcparht}{\ht\tempsbox}%
%                                 \setlength{\xcpardp}{\dp\tempsbox}%
%                                 \addtolength{\xcparht}{.15em}%
%                                 \addtolength{\xcpardp}{.2em}%
%                                 \addtolength{\xcparht}{\xcpardp}%
%                                 \hspace*{-\lcomindent}%
%                                 \makebox[0pt][l]{\raisebox{-\xcpardp}[0pt][0pt]{%
%                                      \shadebox{\rule{0pt}{\xcparht}\hspace*{\textwidth}}}}%
%                                 \hspace*{\lcomindent}\usebox{\tempsbox}%
%                                 \par}{}%
%  }
%  
% \newlength{\xmcomlen}
%\newenvironment{xmcom}[1]{%
%  \setcounter{pardepth}{0}%
%  \hspace{.65em}%
%  \begin{lrbox}{\alignbox}\sloppypar%
%      \setboolean{shading}{false}%
%      \setlength{\boxwidth}{#1pt}%
%      \addtolength{\boxwidth}{-.65em}%
%      \begin{minipage}[t]{\boxwidth}\footnotesize
%      \parskip=0pt\relax}%
%       {\end{minipage}\end{lrbox}%
%       \setlength{\xmcomlen}{\textwidth}%
%       \addtolength{\xmcomlen}{-\wd\alignbox}%
%       \settodepth{\alignwidth}{\usebox{\alignbox}}%
%       \global\setlength{\multicommentdepth}{\alignwidth}%
%       \setlength{\boxwidth}{\alignwidth}%
%       \global\addtolength{\alignwidth}{-\maxdepth}%
%       \addtolength{\boxwidth}{.1em}%
%       \raisebox{0pt}[0pt][0pt]{%
%        \ifthenelse{\boolean{shading}}%
%          {\hspace*{-\xmcomlen}\shadebox{\rule[-\boxwidth]{0pt}{0pt}%
%                                 \hspace*{\xmcomlen}\usebox{\alignbox}}}%
%          {\usebox{\alignbox}}}%
%       \vspace*{\alignwidth}\pagebreak[0]\vspace{-\alignwidth}\par}
% % a multi-line comment, whose first argument is its width in points.
%  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE lcom ENVIRONMENT                                                       %
% ^^^^^^^^^^^^^^^^^^^^                                                       %
% A multi-line comment with no text to its left is typeset in an lcom        % 
% environment, whose argument is a number representing the indentation       % 
% of the left margin, in points.  All the text of the comment should be      % 
% inside cpar environments.                                                  % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newenvironment{lcom}[1]{%
    \setlength{\lcomindent}{#1pt} % Added for PlusCal handling.
    \par\vspace{.2em}%
    \sloppypar
    \setcounter{pardepth}{0}%
    \footnotesize
    \begin{list}{}{%
            \setlength{\leftmargin}{#1pt}
            \setlength{\labelwidth}{0pt}%
            \setlength{\labelsep}{0pt}%
            \setlength{\itemindent}{0pt}%
            \setlength{\topsep}{0pt}%
            \setlength{\parsep}{0pt}%
            \setlength{\partopsep}{0pt}%
            \setlength{\parskip}{0pt}}
        \item[]}%
        {\end{list}\vspace{.3em}\setlength{\lcomindent}{0pt}%
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE mcom ENVIRONMENT AND \mutivspace COMMAND                              %
% ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                              %
%                                                                           %
% A part of the spec containing a right-comment of the form                 %
%                                                                           %
%      xxxx (*************)                                                 %
%      yyyy (* ccccccccc *)                                                 %
%      ...  (* ccccccccc *)                                                 %
%           (* ccccccccc *)                                                 %
%           (* ccccccccc *)                                                 %
%           (*************)                                                 %
%                                                                           %
% is typeset by                                                             %
%                                                                           %
%     XXXX \begin{mcom}{d}                                                  %
%            CCCC ... CCC                                                   %
%          \end{mcom}                                                       %
%     YYYY ...                                                              %
%     \multivspace{n}                                                       %
%                                                                           %
% where the number d is the width in points of the comment, n is the        %
% number of xxxx, yyyy, ...  lines to the left of the comment.              %
% All the text of the comment should be typeset in cpar environments.       %
%                                                                           %
% This puts the comment into a single box (so no page breaks can occur      %
% within it).  The entire box is shaded iff the shading flag is true.       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newlength{\xmcomlen}%
\newenvironment{mcom}[1]{%
    \setcounter{pardepth}{0}%
    \hspace{.65em}%
    \begin{lrbox}{\alignbox}\sloppypar%
        \setboolean{shading}{false}%
        \setlength{\boxwidth}{#1pt}%
        \addtolength{\boxwidth}{-.65em}%
        \begin{minipage}[t]{\boxwidth}\footnotesize
            \parskip=0pt\relax}%
            {\end{minipage}\end{lrbox}%
    \setlength{\xmcomlen}{\textwidth}%       % For PlusCal shading
    \addtolength{\xmcomlen}{-\wd\alignbox}%  % For PlusCal shading
    \settodepth{\alignwidth}{\usebox{\alignbox}}%
    \global\setlength{\multicommentdepth}{\alignwidth}%
    \setlength{\boxwidth}{\alignwidth}%      % For PlusCal shading
    \global\addtolength{\alignwidth}{-\maxdepth}%
    \addtolength{\boxwidth}{.1em}%           % For PlusCal shading
    \raisebox{0pt}[0pt][0pt]{%
        \ifthenelse{\boolean{shading}}%
        {\ifpcalshading
                \hspace*{-\xmcomlen}%
                \shadebox{\rule[-\boxwidth]{0pt}{0pt}\hspace*{\xmcomlen}%
                    \usebox{\alignbox}}%
            \else
                \shadebox{\usebox{\alignbox}}
            \fi
        }%
        {\usebox{\alignbox}}}%
    \vspace*{\alignwidth}\pagebreak[0]\vspace{-\alignwidth}\par}
% a multi-line comment, whose first argument is its width in points.


% \multispace{n} produces the vertical space indicated by "|"s in 
% this situation
%   
%     xxxx (*************)
%     xxxx (* ccccccccc *)
%      |   (* ccccccccc *)
%      |   (* ccccccccc *)
%      |   (* ccccccccc *)
%      |   (*************)
%
% where n is the number of "xxxx" lines.
\newcommand{\multivspace}[1]{\addtolength{\multicommentdepth}{-#1\baselineskip}%
    \addtolength{\multicommentdepth}{1.2em}%
    \ifthenelse{\lengthtest{\multicommentdepth > 0pt}}%
    {\par\vspace{\multicommentdepth}\par}{}}

%\newenvironment{hpar}[2]{%
%  \begin{list}{}{\setlength{\leftmargin}{#1pt}%
%                 \addtolength{\leftmargin}{#2pt}%
%                 \setlength{\itemindent}{-#2pt}%
%                 \setlength{\topsep}{0pt}%
%                 \setlength{\parsep}{0pt}%
%                 \setlength{\partopsep}{0pt}%
%                 \setlength{\parskip}{0pt}%
%                 \addtolength{\labelsep}{0pt}}%
%  \item[]\footnotesize}{\end{list}}
%    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    % Typesets a sequence of paragraphs like this:                         %
%    %                                                                      %
%    %      left |<-- d1 --> XXXXXXXXXXXXXXXXXXXXXXXX                       %
%    %    margin |           <- d2 -> XXXXXXXXXXXXXXX                       %
%    %           |                    XXXXXXXXXXXXXXX                       %
%    %           |                                                          %
%    %           |                    XXXXXXXXXXXXXXX                       %
%    %           |                    XXXXXXXXXXXXXXX                       %
%    %                                                                      %
%    % where d1 = #1pt and d2 = #2pt, but with no vspace between            %
%    % paragraphs.                                                          %
%    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Commands for repeated characters that produce dashes.              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raisedDash{wd}{ht}{thk} makes a horizontal line wd characters wide, 
% raised a distance ht ex's above the baseline, with a thickness of 
% thk em's.
\newcommand{\raisedDash}[3]{\raisebox{#2ex}{\setlength{\alignwidth}{.5em}%
        \rule{#1\alignwidth}{#3em}}}

% The following commands take a single argument n and produce the
% output for n repeated characters, as follows
%   \cdash:    -
%   \tdash:    ~
%   \ceqdash:  =
%   \usdash:   _
\newcommand{\cdash}[1]{\raisedDash{#1}{.5}{.04}}
\newcommand{\usdash}[1]{\raisedDash{#1}{0}{.04}}
\newcommand{\ceqdash}[1]{\raisedDash{#1}{.5}{.08}}
\newcommand{\tdash}[1]{\raisedDash{#1}{1}{.08}}

\newlength{\spacewidth}
\setlength{\spacewidth}{.2em}
\newcommand{\e}[1]{\hspace{#1\spacewidth}}
%% \e{i} produces space corresponding to i input spaces.


%% Alignment-file Commands

\newlength{\alignboxwidth}
\newlength{\alignwidth}
\newsavebox{\alignbox}

% \al{i}{j}{txt} is used in the alignment file to put "%{i}{j}{wd}"
% in the log file, where wd is the width of the line up to that point,
% and txt is the following text.
\newcommand{\al}[3]{%
\typeout{\%{#1}{#2}{\the\alignwidth}}%
\cl{#3}}

%% \cl{txt} continues a specification line in the alignment file
%% with text txt.
\newcommand{\cl}[1]{%
    \savebox{\alignbox}{\mbox{$\mbox{}#1\mbox{}$}}%
    \settowidth{\alignboxwidth}{\usebox{\alignbox}}%
    \addtolength{\alignwidth}{\alignboxwidth}%
    \usebox{\alignbox}}

% \fl{txt} in the alignment file begins a specification line that
% starts with the text txt.
\newcommand{\fl}[1]{%
    \par
    \savebox{\alignbox}{\mbox{$\mbox{}#1\mbox{}$}}%
    \settowidth{\alignwidth}{\usebox{\alignbox}}%
    \usebox{\alignbox}}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ordinarily, TeX typesets letters in math mode in a special math italic    %
% font.  This makes it typeset "it" to look like the product of the         %
% variables i and t, rather than like the word "it".  The following         %
% commands tell TeX to use an ordinary italic font instead.                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifx\documentclass\undefined
\else
    \DeclareSymbolFont{tlaitalics}{\encodingdefault}{cmr}{m}{it}
    \let\itfam\symtlaitalics
\fi

\makeatletter
\newcommand{\tlx@c}{\c@tlx@ctr\advance\c@tlx@ctr\@ne}
\newcounter{tlx@ctr}
\c@tlx@ctr=\itfam \multiply\c@tlx@ctr"100\relax \advance\c@tlx@ctr "7061\relax
\mathcode`a=\tlx@c \mathcode`b=\tlx@c \mathcode`c=\tlx@c \mathcode`d=\tlx@c
\mathcode`e=\tlx@c \mathcode`f=\tlx@c \mathcode`g=\tlx@c \mathcode`h=\tlx@c
\mathcode`i=\tlx@c \mathcode`j=\tlx@c \mathcode`k=\tlx@c \mathcode`l=\tlx@c
\mathcode`m=\tlx@c \mathcode`n=\tlx@c \mathcode`o=\tlx@c \mathcode`p=\tlx@c
\mathcode`q=\tlx@c \mathcode`r=\tlx@c \mathcode`s=\tlx@c \mathcode`t=\tlx@c
\mathcode`u=\tlx@c \mathcode`v=\tlx@c \mathcode`w=\tlx@c \mathcode`x=\tlx@c
\mathcode`y=\tlx@c \mathcode`z=\tlx@c
\c@tlx@ctr=\itfam \multiply\c@tlx@ctr"100\relax \advance\c@tlx@ctr "7041\relax
\mathcode`A=\tlx@c \mathcode`B=\tlx@c \mathcode`C=\tlx@c \mathcode`D=\tlx@c
\mathcode`E=\tlx@c \mathcode`F=\tlx@c \mathcode`G=\tlx@c \mathcode`H=\tlx@c
\mathcode`I=\tlx@c \mathcode`J=\tlx@c \mathcode`K=\tlx@c \mathcode`L=\tlx@c
\mathcode`M=\tlx@c \mathcode`N=\tlx@c \mathcode`O=\tlx@c \mathcode`P=\tlx@c
\mathcode`Q=\tlx@c \mathcode`R=\tlx@c \mathcode`S=\tlx@c \mathcode`T=\tlx@c
\mathcode`U=\tlx@c \mathcode`V=\tlx@c \mathcode`W=\tlx@c \mathcode`X=\tlx@c
\mathcode`Y=\tlx@c \mathcode`Z=\tlx@c
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                THE describe ENVIRONMENT                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% It is like the description environment except it takes an argument
% ARG that should be the text of the widest label.  It adjusts the
% indentation so each item with label LABEL produces
%%      LABEL             blah blah blah
%%      <- width of ARG ->blah blah blah
%%                        blah blah blah
\newenvironment{describe}[1]%
{\begin{list}{}{\settowidth{\labelwidth}{#1}%
            \setlength{\labelsep}{.5em}%
            \setlength{\leftmargin}{\labelwidth}% 
            \addtolength{\leftmargin}{\labelsep}%
            \addtolength{\leftmargin}{\parindent}%
            \def\makelabel##1{\rm ##1\hfill}}%
        \setlength{\topsep}{0pt}}%% 
        % Sets \topsep to 0 to reduce vertical space above
        % and below embedded displayed equations
        {\end{list}}

%   For tlatex.TeX
\usepackage{verbatim}
\makeatletter
\def\tla{\let\%\relax%
\@bsphack
\typeout{\%{\the\linewidth}}%
\let\do\@makeother\dospecials\catcode`\^^M\active
\let\verbatim@startline\relax
\let\verbatim@addtoline\@gobble
\let\verbatim@processline\relax
\let\verbatim@finish\relax
\verbatim@}
\let\endtla=\@esphack

\let\pcal=\tla
\let\endpcal=\endtla
\let\ppcal=\tla
\let\endppcal=\endtla

% The tlatex environment is used by TLATeX.TeX to typeset TLA+.
% TLATeX.TLA starts its files by writing a \tlatex command.  This
% command/environment sets \parindent to 0 and defines \% to its
% standard definition because the writing of the log files is messed up
% if \% is defined to be something else.  It also executes
% \@computerule to determine the dimensions for the TLA horizonatl
% bars.
\newenvironment{tlatex}{\@computerule%
    \setlength{\parindent}{0pt}%
    \makeatletter\chardef\%=`\%}{}


% The notla environment produces no output.  You can turn a 
% tla environment to a notla environment to prevent tlatex.TeX from
% re-formatting the environment.

\def\notla{\let\%\relax%
    \@bsphack
    \let\do\@makeother\dospecials\catcode`\^^M\active
    \let\verbatim@startline\relax
    \let\verbatim@addtoline\@gobble
    \let\verbatim@processline\relax
    \let\verbatim@finish\relax
    \verbatim@}
\let\endnotla=\@esphack

\let\nopcal=\notla
\let\endnopcal=\endnotla
\let\noppcal=\notla
\let\endnoppcal=\endnotla


\begin{document}

%----------------------------
% BEGIN HEADER PORTION
%----------------------------
\hspace*{-10mm} \framebox{
    \begin{minipage}[t]{\textwidth}
        \vspace{1ex}
        {\large\bf  \course} \hfill {\large\bf Name: \name}\\[1ex]
        {\bf \title \hfill   Due: \due}
        \vspace{1ex}

    \end{minipage}
}%% end framebox
\vskip 0.1in


%----------------------------
% END HEADER PORTION
%----------------------------

\section{Hazard Pointer Modeling}
\subsection{Problem}

\quad \quad With the slowing of Moore's Law, computing has set off in search of ways to satiate our growing need for computing power. Moving away from monolithic systems that operate on a single core without comunicating with the outside world has led us to find a better way to scale: distributed computing. Distributed computing relies on many computation objects to solve our problems in parallel (whether it be machines, cores, or hyperthreading). In order to efficiently comunicate and use these kinds of systems, we have developed data structures where many readers and writers can concurrently share the same structure. \\

When going from normal data structures to concurrent ones, we run into many synchronization issues. Reading from a memory locaiton is unstable because a concurrent writer could be shifting the data out from under us. If we read a value, it could instantly be invalidated before we can perform some meaningful computation on it. We also care about the order of things. If we read something, we want to perform our computation and write an update back while preventing others from computing on old data. All of these problems must be addressed in order for users of a concurrent data structure to build their business logic and be able to reason about their code with the level of abstractions that a single threaded environment provides them. This is especially important for abstracting away business logic from computing semantics in a complex system.\\

One solution to the problem of concurrent reading and writing is through locking. A lock is simply an atomic marker that lets only one thread access a data structure at a time. This serializes reads and writes, solving our initial problem. A lock has the idea of acquire and release operations which protect the underlying data. Locking structures have "critical sections" of the code where the lock is acquired and all other concurrent processes must wait until the lock is released. \\

Locking leads to many problems for performant systems. A system that uses a complex data structure like an AVL tree might use a global lock to serialize reads and writes. This would work in theory, but when put to the test, the system breaks down with contention on the lock. A common scenario is for many readers to want access to the system while only a couple of writers try to update it. For the many readers, they all must wait for each other while the underlying data may not even be changing. One way to solve this is to have granular locking, which places many locks on individual subsets of the data structure. This serializes access but requires deep tracking of the locking structures and also has a slight memory overhead for keeping track of all of the locks. Even still, granular locking still falls prey to contention with readers. An example of this would be a concurrent list where 20 readers are all trying to read the head of the list. No ammount of granularization would assist in this case. \\

Locking leads to deadlock, which is where a thread cannot proceed because the lock is taken indefinitely. It also leads to interesting edge cases where a thread that dies with a held lock leaves the lock forever deadlocked for other threads. \\

These issues have led to the invention of lock-free concurrent data structures. They attempt to prevent contention by removing locks all-together. This is achieved through atomic instructions that can swap values based on what is already there. This is called a compare and set instruction. Usually these are used to compare and set pointers to the data structures they are protecting. \\

Lock-free algorithms are appealing because they allow for truly concurrent reads and atomic writes. This means that readers can keep reading without delay if the value underneath has not changed. \\

One problem that comes up in the lock-free world is the ABA problem. It based on a reader reading a value A and performing some meaningful computation on the value. Another thread comes along and changes the value to B and then back to A underneath of the reader thread. This tricks the original thread into thinking it still has the most current value even though there have been hidden writes underneath of it. This shows that while lock-free algorithms yield better performance, they are dangerous because they give rise to new forms problems. \\

All of this has led up to the main topic of this paper: hazard pointers. A hazard pointer is a lock-free, wait-free primitive to wrap around a data structure that is optimized for many readers and rare writes. It was introduced in 2004 by Andrei Alexandrescu and Maged Michael. It improves upon previous compare and set algorithms by providing a solidly defined solution to the ABA problem. Facebook has recently used hazard pointers in its open source repository of C++ data structures and algorithms, \href{https://github.com/facebook/folly}{folly}. \\

Hazard pointers almost keep track of epochs of models of the underlying data structure. Every write produces a new copy of the data structure. Hazard pointers model readers as users which keep track of which pointers are currently in use (a single hazard pointer is an active pointer to a copy of the model at a point in time). Writers are modeled as removers/reclaimers, which are able to sort through all of the hazard pointers that are valid and reclaim the memory of those that are not active and are no longer referenced. This is very similar to epoch based garbage collection except we get ABA-safe readers and better interleaving of operations than a full garbage collected system. The following image describes the interaction: \\

\begin{center}
    \includegraphics[width=14cm]{images/hzd_ptr_model}
\end{center}

A full hazard pointer structure is made up of global state and per-thread state. The global state includes a linked list of all of the hazard records. Each hazard record is used to track a hazard pointer and its status as being active or inactive. A hazard pointer being active is just a claim to not remove that particular instance of the data structure. The following image shows a diagram of the structure: \\

\begin{center}
    \includegraphics[width=14cm]{images/hzd_rec}
\end{center}

The hazard record list is actually not needed to be a linked list. It is simply a set of active hazard pointers and could be optimized in a different implementation. We will see later in my modeling how this quirk becomes useful in abstracting this structure. \\

Each thread labeled as a writer has both the writing and reclamation responsibilities. The writing is done by allocating a new copy of the structure with the desired update. The reclamation is done by looping through any structures marked as no longer needed by readers (hazard records that are active) and performing a set difference with the currently allocated structures. In order to achieve this, the writers need to track revocations for later reclamation. This is done through a thread local structure called the revocation list. It is simply a set of hazard pointers that have been marked for reclamation. \\

Hazard pointers attack the ABA problem by limiting readers to their own worlds. Readers get a pointer to a structure that they can freely read from without worrying about other writes coming in on top. One thing that readers cannot do is write to their returned pointer's structure. Readers from the same epoch share the same underlying structure. This also means that multiple hazard records can point to the same underlying structure (writers must wait for all readers to be done with a structure to reclaim the memory).

\subsection{Approach}

\quad \quad I chose TLA+ to model my system. I think that is lends itself to this particular challenge better than any other modeling system. TLA+ itself allows for global state machine logic which is actually not very suited to our problem. We want to model concurrent processes that do not respect each other to allow them to have execution time (unfair). Luckily, PlusCal adds these constructs on top of TLA+. \\

I used PlusCal's concurrency model to create separate concurrent processes for the readers and writers. PlusCal by default creates unfair processes that do not wait for each other. These features are added in as keywords, so my logic is that if I can get a valid hazard pointer model written in PlusCal that never uses $await$ or $fair$, then I have proved that the algorithm is wait free. Another goal is to prove that the algorithm never halts which is built into the TLC checker with deadlock checking. This lets me exhaustively check that hazard pointers will not fail in their normal operation. \\

This model also lets me use PlusCal's $assert$ call to check that there is never a state where a read can be modified underneath of itself. This verifies the logic behind the ABA problem's solution in hazard pointers. \\

I began by modeling a simple global lock system to be able to compare the number of waits needed in the algorithm. This model simply used a shared mutex to lock the number to write. I verified using $assert$ debugging that critical sections were not executed concurrently. Unfortunately, there is no way to incorporate performance modeling into TLA+. \\

The folly repository uses its hazard pointer implementation to implement a concurrent hash-map. I actually attempted to fully model their implementation of a hazard pointer concurrent hash-map, but the model ended up having too many states to verify. Because of TLA+'s graph-based exhaustive search through the model's state space, I was limited by my machine's resources and I actually was unable to finish evaluation before my laptop ran out of memory. I ended up modeling only a simple integer reading and writing model. \\

Modeling the simplified integer read/write model ended up being tricky because I had to model pointers within TLA+. There is no concept of a memory address pointer in this language, so I had to come up with a way to model what hazard pointers were achieving in a creative way. I used a timeline based approach with a mapping. By keeping track of each new write as a separate entry in a sequence, I was able to mimic temporal structures within a temporal language. This ended up being equivalent to pointers because every structure is only written once and is then never updated. \\

One part of the system that I was unable to model was the failure of reader threads. I did not find a simple way to make PlusCal processes crash randomly. Also, it is unclear how to formalize memory reclamation when there is no equivalent to the destruction of objects in logic (they are just no longer in existance once no longer referenced). If a reader thread fails during its active time, it will basically pin a copy of the internal data structure because the active flag will never be unset.

\subsection{Results}

\quad \quad I was able to successfully model the system based on the abstractions listed above. The model showed that the simple model fully serialized actions while the hazard pointer model safely interleaved reads with writes. I showed that the system did not need to wait by never using the $await$ keyword in my model. \\

This model implies that it is safe to use hazard pointers in their intended use case. It did not, however, prove that failure could not mess up the memory usage in a system. Thread failures could leave memory zombified to dead readers. In theory, memory may run out due to this quirk of the system. From there, the model does not define what will happen. \\

I think that the end result is a great primitive for efficient, lock-free data structures. I would caution implementers with the edge cases that my modeling cannot verify. The folly repository also leaves this edge case open to the machine the code is running on. This could be dangerous for high assurance systems that need to have every edge case covered.

\subsection{Limitations and Future Work}

\quad \quad State space explosion is a big problem for sufficiently complex systems. Memory usage is something that is difficult to model without writing an entire model for the memory (and having a massive state space explosion as well as issues with memory limits). I was limited in my ability to represent complex data structures as well. \\

The ability to kill readers and show the effects on the algorithm was a limitation of the modeling suite. I think future work could improve upon this by attempting to write some form of penalty function for readers that fail. I think it could scale based on the number of readers that are impacted by a single reader failing during its active record state. \\

One possible extension to the work would be to model the interleaving of hazard pointers with other lock-free primitives. I think that the reclamation methods in hazard pointers could be utilized in creative ways to synergize with lock-free systems that front load work to readers rather than writers.

\subsection{Supplementary Information}
\textbf{Simple Lock:} \\
\tlatex
\@x{}\moduleLeftDash\@xx{ {\MODULE} simple\_lock}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals ,\, TLC}%
\@x{ {\CONSTANTS} NumReaders ,\, NumWrites}%
\@pvspace{8.0pt}%
\pcalsymbolstrue
\csyntaxfalse
\@x{\@s{12.29} {\p@mmalgorithm} simple\_lock}%
\@x{ {\p@variables} cur \.{=} 0 ,\, lock \.{=} 0}%
\@pvspace{8.0pt}%
\@x{ {\p@process} writer \.{=} 1}%
\@x{ {\p@variable} write\@s{1.79} \.{=} 0}%
\@x{ {\p@begin}}%
\@x{ Writer\_Loop\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@while} write \.{\neq} NumWrites {\p@do}}%
\@x{\@s{32.8} Write\_Acquire\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{49.19} {\p@await} lock \.{=} 0 {\p@semicolon}}%
\@x{\@s{49.19} lock \.{:=} 1 {\p@semicolon}}%
\@x{\@s{32.8} Update\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{49.19} cur \.{:=} write {\p@semicolon}}%
\@x{\@s{32.8} Write\_Release\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{49.19} lock \.{:=} 0 {\p@semicolon}}%
\@x{\@s{16.4} {\p@end} {\p@while} {\p@semicolon}}%
\@x{ {\p@end} {\p@process} {\p@semicolon}}%
\@pvspace{8.0pt}%
\@x{ {\p@process} reader \.{\in} 2 \.{\dotdot} ( NumReaders \.{+} 1 )}%
\@x{ {\p@variables} saved\_read}%
\@x{ {\p@begin}}%
\@x{ Read\_Acquire\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@await} lock \.{=} 0 {\p@semicolon}}%
\@x{\@s{16.4} lock \.{:=} 1 {\p@semicolon}}%
\@x{ Read\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} saved\_read \.{:=} cur {\p@semicolon}}%
\@x{ Check\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@assert} saved\_read \.{=} cur {\p@semicolon}}%
\@x{ Read\_Release\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} lock \.{:=} 0 {\p@semicolon}}%
\@x{ {\p@end} {\p@process} {\p@semicolon}}%
\@pvspace{8.0pt}%
\@x{ {\p@end} {\p@algorithm}}%
\@y{;}
\@xx{}%
\pcalshadingfalse \pcalsymbolsfalse
\@x{}%
\@y{\@s{0}%
BEGIN TRANSLATION (\ensuremath{chksum(pcal) \.{=}} ``\ensuremath{1359a2df}''
\ensuremath{\.{\land} chksum(tla) \.{=}} ``\ensuremath{8136cae}'')
}%
\@xx{}%
\@x{ {\CONSTANT} defaultInitValue}%
\@x{ {\VARIABLES} cur ,\, lock ,\, pc ,\, write ,\, saved\_read}%
\@pvspace{8.0pt}%
\@x{ vars \.{\defeq} {\langle} cur ,\, lock ,\, pc ,\, write ,\, saved\_read
{\rangle}}%
\@pvspace{8.0pt}%
\@x{ ProcSet \.{\defeq} \{ 1 \} \.{\cup} ( 2 \.{\dotdot} ( NumReaders \.{+} 1
) )}%
\@pvspace{8.0pt}%
\@x{ Init \.{\defeq}}%
\@y{\@s{0}%
    Global variables
}%
\@xx{}%
\@x{\@s{35.70} \.{\land} cur \.{=} 0}%
\@x{\@s{35.70} \.{\land} lock \.{=} 0}%
\@x{\@s{35.70}}%
\@y{\@s{0}%
    Process writer
}%
\@xx{}%
\@x{\@s{35.70} \.{\land} write \.{=} 0}%
\@x{\@s{35.70}}%
\@y{\@s{0}%
    Process reader
}%
\@xx{}%
\@x{\@s{35.70} \.{\land} saved\_read \.{=} [ self \.{\in} 2 \.{\dotdot} (
NumReaders \.{+} 1 ) \.{\mapsto} defaultInitValue ]}%
\@x{\@s{35.70} \.{\land} pc \.{=} [ self\@s{5.27} \.{\in} ProcSet \.{\mapsto}
{\CASE} self \.{=} 1 \.{\rightarrow}\@w{Writer\_Loop}}%
\@x{\@s{165.66} {\Box}\@s{10.30} self \.{\in} 2 \.{\dotdot} ( NumReaders
\.{+} 1 ) \.{\rightarrow}\@w{Read\_Acquire} ]}%
\@pvspace{8.0pt}%
\@x{ Writer\_Loop \.{\defeq} \.{\land} pc [ 1 ] \.{=}\@w{Writer\_Loop}}%
\@x{\@s{75.09} \.{\land} {\IF} write \.{\neq} NumWrites}%
\@x{\@s{98.35} \.{\THEN} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ 1
    ] \.{=}\@w{Write\_Acquire} ]}%
\@x{\@s{98.35} \.{\ELSE} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ 1
    ] \.{=}\@w{Done} ]}%
\@x{\@s{75.09} \.{\land} {\UNCHANGED} {\langle} cur ,\, lock ,\, write ,\,
saved\_read {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Write\_Acquire \.{\defeq} \.{\land} pc [ 1 ] \.{=}\@w{Write\_Acquire}}%
\@x{\@s{82.43} \.{\land} lock \.{=} 0}%
\@x{\@s{82.43} \.{\land} lock \.{'} \.{=} 1}%
\@x{\@s{82.43} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ 1 ]
\.{=}\@w{Update} ]}%
\@x{\@s{82.43} \.{\land} {\UNCHANGED} {\langle} cur ,\, write ,\, saved\_read
{\rangle}}%
\@pvspace{8.0pt}%
\@x{ Update \.{\defeq} \.{\land} pc [ 1 ] \.{=}\@w{Update}}%
\@x{\@s{49.81} \.{\land} cur \.{'} \.{=} write}%
\@x{\@s{49.81} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ 1 ]
\.{=}\@w{Write\_Release} ]}%
\@x{\@s{49.81} \.{\land} {\UNCHANGED} {\langle} lock ,\, write ,\,
saved\_read {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Write\_Release \.{\defeq} \.{\land} pc [ 1 ] \.{=}\@w{Write\_Release}}%
\@x{\@s{81.91} \.{\land} lock \.{'}\@s{0.08} \.{=} 0}%
\@x{\@s{81.91} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ 1 ]
\.{=}\@w{Writer\_Loop} ]}%
\@x{\@s{81.91} \.{\land} {\UNCHANGED} {\langle} cur ,\, write ,\, saved\_read
{\rangle}}%
\@pvspace{8.0pt}%
\@x{ writer \.{\defeq} Writer\_Loop \.{\lor} Write\_Acquire \.{\lor} Update
\.{\lor} Write\_Release}%
\@pvspace{8.0pt}%
\@x{ Read\_Acquire ( self ) \.{\defeq} \.{\land} pc [ self ]
\.{=}\@w{Read\_Acquire}}%
\@x{\@s{102.82} \.{\land} lock \.{=} 0}%
\@x{\@s{102.82} \.{\land} lock \.{'} \.{=} 1}%
\@x{\@s{102.82} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
\.{=}\@w{Read} ]}%
\@x{\@s{102.82} \.{\land} {\UNCHANGED} {\langle} cur ,\, write ,\,
saved\_read {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Read ( self ) \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{Read}}%
\@x{\@s{65.22} \.{\land} saved\_read \.{'} \.{=} [ saved\_read {\EXCEPT}
{\bang} [ self ] \.{=} cur ]}%
\@x{\@s{65.22} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
\.{=}\@w{Check} ]}%
\@x{\@s{65.22} \.{\land} {\UNCHANGED} {\langle} cur ,\, lock ,\, write
    {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Check ( self ) \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{Check}}%
\@x{\@s{69.72} \.{\land} Assert ( saved\_read [ self ] \.{=} cur ,\,}%
\@x{\@s{113.42}\@w{Failure\ of\ assertion\ at\ line\ 32,\ column\ 5.} )}%
\@x{\@s{69.72} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
\.{=}\@w{Read\_Release} ]}%
\@x{\@s{69.72} \.{\land} {\UNCHANGED} {\langle} cur ,\, lock ,\, write ,\,
saved\_read {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Read\_Release ( self ) \.{\defeq} \.{\land} pc [ self ]
\.{=}\@w{Read\_Release}}%
\@x{\@s{102.30} \.{\land} lock \.{'} \.{=} 0}%
\@x{\@s{102.30} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
\.{=}\@w{Done} ]}%
\@x{\@s{102.30} \.{\land} {\UNCHANGED} {\langle} cur ,\, write ,\,
saved\_read {\rangle}}%
\@pvspace{8.0pt}%
\@x{ reader ( self ) \.{\defeq} Read\_Acquire ( self ) \.{\lor} Read ( self )
\.{\lor} Check ( self )}%
\@x{\@s{83.30} \.{\lor} Read\_Release ( self )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
    Allow infinite stuttering to prevent deadlock on termination.
}%
\@xx{}%
\@x{ Terminating \.{\defeq} \.{\land} \A\, self \.{\in} ProcSet \.{:} pc [
        self ] \.{=}\@w{Done}}%
\@x{\@s{73.56} \.{\land} {\UNCHANGED} vars}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} writer}%
\@x{\@s{52.13} \.{\lor} ( \E\, self \.{\in} 2 \.{\dotdot} ( NumReaders \.{+}
1 ) \.{:} reader ( self ) )}%
\@x{\@s{52.13} \.{\lor} Terminating}%
\@pvspace{8.0pt}%
\@x{ Spec\@s{1.46} \.{\defeq} Init \.{\land} {\Box} [ Next ]_{ vars}}%
\@pvspace{8.0pt}%
\@x{ Termination \.{\defeq} {\Diamond} ( \A\, self \.{\in} ProcSet \.{:} pc [
        self ] \.{=}\@w{Done} )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
    END TRANSLATION
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{}\bottombar\@xx{}%

\noindent \textbf{Simple Lock Configuration:} \\
\begin{verbatim}
SPECIFICATION Spec
CONSTANT defaultInitValue = defaultInitValue
\* Add statements after this line.

CONSTANTS NumReaders = 3
    NumWrites = 3
\end{verbatim}

\noindent \textbf{Hazard Pointer:} \\
\tlatex
\@x{}\moduleLeftDash\@xx{ {\MODULE} hazptr}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals ,\, TLC ,\, FiniteSets ,\, Sequences}%
\@x{ {\CONSTANTS} NumReaders ,\, NumWrites}%
\@pvspace{8.0pt}%
\@x{ R \.{\defeq} 2}%
\@pvspace{8.0pt}%
\pcalsymbolstrue
\csyntaxfalse
\@x{\@s{11.78} {\p@mmalgorithm} hazptr}%
\@x{ {\p@variables} cur \.{=} 0 ,\, hzdreclist \.{=} \{ \} ,\, timeline \.{=}
{\langle} {\rangle}}%
\@pvspace{8.0pt}%
\@x{ {\p@process} writer \.{=} 1}%
\@x{ {\p@variables} old \.{=} 0 ,\, rlist \.{=} \{ \} ,\, write \.{=} 0}%
\@x{ {\p@begin}}%
\@x{ WriterLoop\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@while} write \.{\neq} NumWrites {\p@do}}%
\@x{\@s{16.4} Update\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{32.8} old\@s{1.44} \.{:=} cur {\p@semicolon}}%
\@x{\@s{32.8} cur \.{:=} cur \.{+} 1 {\p@semicolon}}%
\@x{\@s{32.8} timeline \.{:=} Append ( timeline ,\, write ) {\p@semicolon}}%
\@x{\@s{16.4} Retire\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{32.8} rlist \.{:=} rlist \.{\cup} \{ old \} {\p@semicolon}}%
\@x{\@s{16.4} Scan\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{32.8} {\p@if} Cardinality ( rlist ) \.{\geq} R {\p@then}}%
\@x{\@s{47.44}}%
\@y{\@s{0}%
    free all ones without hazard pointers
}%
\@xx{}%
\@x{\@s{47.44} rlist \.{:=} \{ x \.{\in} rlist \.{:} x \.{\in} hzdreclist \}
{\p@semicolon}}%
\@x{\@s{47.44} {\p@print}\@w{cleaned\ rlist} {\p@semicolon}}%
\@x{\@s{32.8} {\p@end} {\p@if} {\p@semicolon}}%
\@x{\@s{32.8} write \.{:=} write \.{+} 1}%
\@x{ {\p@end} {\p@while} {\p@semicolon}}%
\@x{ {\p@end} {\p@process} {\p@semicolon}}%
\@pvspace{8.0pt}%
\@x{ {\p@process} reader \.{\in} 2 \.{\dotdot} NumReaders \.{+} 1}%
\@x{ {\p@variables} saved\_read \.{=} 0 ,\, saved\_read\_ptr \.{=} 0}%
\@x{ {\p@begin}}%
\@x{ Acquire\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@await} 1 \.{\in} {\DOMAIN} timeline {\p@semicolon}}%
\@x{\@s{16.4}}%
\@y{\@s{0}%
    wait until something can be read. This mimics a real function that would
}%
\@xx{}%
\@x{\@s{16.4}}%
\@y{\@s{0}%
    check for the data to not be null
}%
\@xx{}%
\@x{\@s{16.4} hzdreclist \.{:=} hzdreclist \.{\cup} \{ cur \} {\p@semicolon}}%
\@x{ Read\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} saved\_read\_ptr \.{:=} cur {\p@semicolon}}%
\@x{\@s{16.4} saved\_read \.{:=} timeline [ cur ] {\p@semicolon}}%
\@x{ Check\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4}}%
\@y{\@s{0}%
    mimic a pointer dereference
}%
\@xx{}%
\@x{\@s{16.4} {\p@assert} saved\_read \.{=} timeline [ saved\_read\_ptr ]
    {\p@semicolon}}%
\@x{ Release\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} hzdreclist \.{:=} hzdreclist \.{\,\backslash\,} \{ cur \}
{\p@semicolon}}%
\@x{ {\p@end} {\p@process} {\p@semicolon}}%
\@pvspace{8.0pt}%
\@x{ {\p@end} {\p@algorithm}}%
\@y{%
    ;
}%
\@xx{}%
\pcalshadingfalse \pcalsymbolsfalse
\@x{}%
\@y{\@s{0}%
BEGIN TRANSLATION (\ensuremath{chksum(pcal) \.{=}} ``\ensuremath{e300f735}''
\ensuremath{\.{\land} chksum(tla) \.{=}} ``\ensuremath{456bb21d}'')
}%
\@xx{}%
\@x{ {\VARIABLES} cur ,\, hzdreclist ,\, timeline ,\, pc ,\, old ,\, rlist
    ,\, write ,\, saved\_read ,\,}%
\@x{\@s{51.42} saved\_read\_ptr}%
\@pvspace{8.0pt}%
\@x{ vars \.{\defeq} {\langle} cur ,\, hzdreclist ,\, timeline ,\, pc ,\, old
,\, rlist ,\, write ,\, saved\_read ,\,}%
\@x{\@s{41.61} saved\_read\_ptr {\rangle}}%
\@pvspace{8.0pt}%
\@x{ ProcSet \.{\defeq} \{ 1 \} \.{\cup} ( 2 \.{\dotdot} NumReaders \.{+} 1
)}%
\@pvspace{8.0pt}%
\@x{ Init \.{\defeq}}%
\@y{\@s{0}%
    Global variables
}%
\@xx{}%
\@x{\@s{35.70} \.{\land} cur \.{=} 0}%
\@x{\@s{35.70} \.{\land} hzdreclist \.{=} \{ \}}%
\@x{\@s{35.70} \.{\land} timeline \.{=} {\langle} {\rangle}}%
\@x{\@s{35.70}}%
\@y{\@s{0}%
    Process writer
}%
\@xx{}%
\@x{\@s{35.70} \.{\land} old \.{=} 0}%
\@x{\@s{35.70} \.{\land} rlist\@s{4.40} \.{=} \{ \}}%
\@x{\@s{35.70} \.{\land} write \.{=} 0}%
\@x{\@s{35.70}}%
\@y{\@s{0}%
    Process reader
}%
\@xx{}%
\@x{\@s{35.70} \.{\land} saved\_read \.{=} [ self \.{\in} 2 \.{\dotdot}
NumReaders \.{+} 1 \.{\mapsto} 0 ]}%
\@x{\@s{35.70} \.{\land} saved\_read\_ptr \.{=} [ self \.{\in} 2 \.{\dotdot}
NumReaders \.{+} 1 \.{\mapsto} 0 ]}%
\@x{\@s{35.70} \.{\land} pc \.{=} [ self \.{\in} ProcSet \.{\mapsto} {\CASE}
self \.{=} 1 \.{\rightarrow}\@w{WriterLoop}}%
\@x{\@s{160.39} {\Box}\@s{10.30} self \.{\in} 2 \.{\dotdot} NumReaders \.{+}
1 \.{\rightarrow}\@w{Acquire} ]}%
\@pvspace{8.0pt}%
\@x{ WriterLoop \.{\defeq} \.{\land} pc [ 1 ] \.{=}\@w{WriterLoop}}%
\@x{\@s{69.51} \.{\land} {\IF} write \.{\neq} NumWrites}%
\@x{\@s{92.78} \.{\THEN} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ 1
    ] \.{=}\@w{Update} ]}%
\@x{\@s{92.78} \.{\ELSE} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ 1
    ] \.{=}\@w{Done} ]}%
\@x{\@s{69.51} \.{\land} {\UNCHANGED} {\langle} cur ,\, hzdreclist ,\,
timeline ,\, old ,\, rlist ,\, write ,\,}%
\@x{\@s{143.10} saved\_read ,\, saved\_read\_ptr {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Update \.{\defeq} \.{\land} pc [ 1 ] \.{=}\@w{Update}}%
\@x{\@s{49.81} \.{\land} old \.{'}\@s{1.44} \.{=} cur}%
\@x{\@s{49.81} \.{\land} cur \.{'} \.{=} cur \.{+} 1}%
\@x{\@s{49.81} \.{\land} timeline \.{'} \.{=} Append ( timeline ,\, write )}%
\@x{\@s{49.81} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ 1 ]
\.{=}\@w{Retire} ]}%
\@x{\@s{49.81} \.{\land} {\UNCHANGED} {\langle} hzdreclist ,\, rlist ,\,
write ,\, saved\_read ,\, saved\_read\_ptr {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Retire\@s{4.10} \.{\defeq} \.{\land} pc [ 1 ] \.{=}\@w{Retire}}%
\@x{\@s{49.81} \.{\land} rlist \.{'} \.{=} ( rlist \.{\cup} \{ old \} )}%
\@x{\@s{49.81} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ 1 ]
\.{=}\@w{Scan} ]}%
\@x{\@s{49.81} \.{\land} {\UNCHANGED} {\langle} cur ,\, hzdreclist ,\,
timeline ,\, old ,\, write ,\, saved\_read ,\,}%
\@x{\@s{123.40} saved\_read\_ptr {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Scan \.{\defeq} \.{\land} pc [ 1 ] \.{=}\@w{Scan}}%
\@x{\@s{40.10} \.{\land} {\IF} Cardinality ( rlist ) \.{\geq} R}%
\@x{\@s{63.36} \.{\THEN} \.{\land} rlist \.{'} \.{=} \{ x \.{\in} rlist \.{:}
x \.{\in} hzdreclist \}}%
\@x{\@s{94.67} \.{\land} PrintT (\@w{cleaned\ rlist} )}%
\@x{\@s{63.36} \.{\ELSE} \.{\land} {\TRUE}}%
\@x{\@s{94.67} \.{\land} rlist \.{'} \.{=} rlist}%
\@x{\@s{40.10} \.{\land} write \.{'} \.{=} write \.{+} 1}%
\@x{\@s{40.10} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ 1 ]
\.{=}\@w{WriterLoop} ]}%
\@x{\@s{40.10} \.{\land} {\UNCHANGED} {\langle} cur ,\, hzdreclist ,\,
timeline ,\, old ,\, saved\_read ,\,}%
\@x{\@s{113.68} saved\_read\_ptr {\rangle}}%
\@pvspace{8.0pt}%
\@x{ writer \.{\defeq} WriterLoop \.{\lor} Update \.{\lor} Retire \.{\lor}
Scan}%
\@pvspace{8.0pt}%
\@x{ Acquire ( self ) \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{Acquire}}%
\@x{\@s{76.19} \.{\land} 1 \.{\in} {\DOMAIN} timeline}%
\@x{\@s{76.19} \.{\land} hzdreclist \.{'} \.{=} ( hzdreclist \.{\cup} \{ cur
\} )}%
\@x{\@s{76.19} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
\.{=}\@w{Read} ]}%
\@x{\@s{76.19} \.{\land} {\UNCHANGED} {\langle} cur ,\, timeline ,\, old ,\,
rlist ,\, write ,\, saved\_read ,\,}%
\@x{\@s{149.78} saved\_read\_ptr {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Read ( self ) \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{Read}}%
\@x{\@s{65.22} \.{\land} saved\_read\_ptr \.{'} \.{=} [ saved\_read\_ptr
{\EXCEPT} {\bang} [ self ] \.{=} cur ]}%
\@x{\@s{65.22} \.{\land} saved\_read \.{'} \.{=} [ saved\_read {\EXCEPT}
{\bang} [ self ] \.{=} timeline [ cur ] ]}%
\@x{\@s{65.22} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
\.{=}\@w{Check} ]}%
\@x{\@s{65.22} \.{\land} {\UNCHANGED} {\langle} cur ,\, hzdreclist ,\,
timeline ,\, old ,\, rlist ,\, write {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Check ( self ) \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{Check}}%
\@x{\@s{69.72} \.{\land} Assert ( saved\_read [ self ] \.{=} timeline [
        saved\_read\_ptr [ self ] ] ,\,}%
\@x{\@s{113.42}\@w{Failure\ of\ assertion\ at\ line\ 44,\ column\ 5.} )}%
\@x{\@s{69.72} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
\.{=}\@w{Release} ]}%
\@x{\@s{69.72} \.{\land} {\UNCHANGED} {\langle} cur ,\, hzdreclist ,\,
timeline ,\, old ,\, rlist ,\, write ,\,}%
\@x{\@s{143.31} saved\_read ,\, saved\_read\_ptr {\rangle}}%
\@pvspace{8.0pt}%
\@x{ Release ( self ) \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{Release}}%
\@x{\@s{75.67} \.{\land} hzdreclist \.{'} \.{=} hzdreclist \.{\,\backslash\,}
\{ cur \}}%
\@x{\@s{75.67} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
\.{=}\@w{Done} ]}%
\@x{\@s{75.67} \.{\land} {\UNCHANGED} {\langle} cur ,\, timeline ,\, old ,\,
rlist ,\, write ,\, saved\_read ,\,}%
\@x{\@s{149.26} saved\_read\_ptr {\rangle}}%
\@pvspace{8.0pt}%
\@x{ reader ( self ) \.{\defeq} Acquire ( self ) \.{\lor} Read ( self )
\.{\lor} Check ( self ) \.{\lor} Release ( self )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
    Allow infinite stuttering to prevent deadlock on termination.
}%
\@xx{}%
\@x{ Terminating \.{\defeq} \.{\land} \A\, self \.{\in} ProcSet \.{:} pc [
        self ] \.{=}\@w{Done}}%
\@x{\@s{73.56} \.{\land} {\UNCHANGED} vars}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} writer}%
\@x{\@s{52.13} \.{\lor} ( \E\, self \.{\in} 2 \.{\dotdot} NumReaders \.{+} 1
\.{:} reader ( self ) )}%
\@x{\@s{52.13} \.{\lor} Terminating}%
\@pvspace{8.0pt}%
\@x{ Spec\@s{1.46} \.{\defeq} Init \.{\land} {\Box} [ Next ]_{ vars}}%
\@pvspace{8.0pt}%
\@x{ Termination \.{\defeq} {\Diamond} ( \A\, self \.{\in} ProcSet \.{:} pc [
        self ] \.{=}\@w{Done} )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
    END TRANSLATION
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{}\bottombar\@xx{}%

\noindent \textbf{Hazard Pointer Configuration:} \\
\begin{verbatim}
SPECIFICATION Spec
\* Add statements after this line.
\* SPECIFICATION
\* Uncomment the previous line and provide the specification name if it's declared
\* in the specification file. Comment INIT / NEXT parameters if you use SPECIFICATION.

CONSTANTS
    NumReaders = 3
    NumWrites = 4
\end{verbatim}

\section{Reflection}

\subsection{Strengths and Weaknesses}

\quad \quad TLA+ with PlusCal ended up being a great higher level modeling language that allowed me to reason closer to the impementation rather than logic. I enjoyed using the builtins for printing and support for common data structures. \\

I think the library system that comes by default in TLA+ leads to a more complex, descriptive set of language structures than Alloy. I think that the learning curve was actually steeper than Alloy for someone just coming from a formal methods course. I ended up leaning heavily on the translations from PlusCal to TLA to understand the underlying semantics of high level PlusCal code. \\

I found the concurrency model to be the perfect combination of Alloy and FSP. It allowed me to specify both structure and events in a very simple way. The disadvantage here was that the intersection of these led to really complex TLA code. TLA does not have native support for this concurrency so it ended up translating local process state to a weird, indexed global state. I think further modeling would have yielded unreadable TLA translations. \\

Finally, I was unable to visualize my model with TLA+. This is something that I leaned on heavily during my time with Alloy. I ended up using TLC's $print$ statement which seemed like the wrong way to debug a model.

\subsection{When Not to Use TLA+}

\quad \quad I would not recommend TLA+ when the model is sufficiently complex. I found the module system in Alloy to be much simpler to understand and also to scale. State space explosion was a real issue for me. \\

I also think that TLA+ does not lend itself to beginners as well as advertised. Beginners will have much better success with FSP, where the model is very simple transitions with visualizations. PlusCal feels like it requires intimate knowledge of TLA to even begin, yet the claim is that PlusCal allows engineers to have a lower barrier of entry to modeling. Don't misunderstand me, I loved using PlusCal and probaly will default to using it when I need to model things in the future.

\subsection{Most Important Improvement}

\quad \quad I think that the best improvement to TLA+ would be a really robust visualization system like Alloy. Something that could be adapted by users to better show traces of the model would be extremely useful during development and also for communication to others about the model without having to show them the raw mathematics.

\end{document}
